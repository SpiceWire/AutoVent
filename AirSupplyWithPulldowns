//
// This sketch operates a fresh air vent. The vent resupplies fresh air for exhaust fans and combustion air.
// In this version, the vent opens when the thermostat calls the furnace for heat. The vent is composed 
// of a sliding door driven by a lead screw connected to a reversible motor. 
//
// Arduino's heat call pin should be connected to Normally Open side of the furnace switch/relay.
// When there is a furnace call for heat, the furnace relay closes and heatCallReading will read HIGH.
//
// There are two methods to prevent overtravel of the vent door. A roller switch (maxOpenLimitSw and maxClosedLimitSw
// below) engage the lead screw's carriage at the limit of travel on each end. The roller switches signal the 
// microcontroller to stop the motor (by use of a relay) before the limit of travel. They also inform the Arduino of the 
// carriage's position when the call for heat is turned on and off. 
//
// In addition, vent door overtravel is prevented by two additional mechanical roller microswitches wired 
// in series with the relays. If the software-driven relays fail to stop the door for whatever reason, the 
// carriage would engage a secondary switch that shuts off power to the motor. 
//
// The signal from the furnace is sent from a solenoid relay, which can send "dirty" signals that need debouncing.
// Debouncing time is lengthy in order to account for situations where the thermostat is accidentally switched
// to "Heat" when manually operated.
//
// This version of the Arduino sketch assumes external pulldown resistors are being used with the switches.

//vars
//pins
//const int otherCallPin = 4;      // digital pin number, input from non-furnace needs for air. Sets the ventCall value
const int heatCallPin = 5;      // digital pin number, input from heat call relay
const int maxOpenLimitSw = 6;   // max open limit switch. Switch (NC) opens when vent is open at max. Pin is LOW when vent is open, HIGH when vent is closed.
const int maxClosedLimitSw = 7; // max closed limit switch. Switch (NC) opens when vent is closed at max. Pin is LOW when vent is closed, HIGH when vent is open.
const int rlyOpenVent = 9;      // relay control to open the vent
const int rlyCloseVent = 10;    // relay control to close the vent

//values
int heatCall = 0;            // Is there a call for heat?
int heatCallReading = 0;             // present reading from heatCallPin
int lastHeatCallReading = 0;         // stores last reading from heatCallPin
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 10000;   // the debounce time; increase if the output flickers

void setup() {
  pinMode(heatCallPin, INPUT);      // HIGH when there is a call from the furnace for heat
  pinMode(maxOpenLimitSw, INPUT);   // LOW when vent is fully open, else HIGH
  pinMode(maxClosedLimitSw, INPUT); // LOW when vent is fully closed, else HIGH

  pinMode(rlyOpenVent, OUTPUT);
  pinMode(rlyCloseVent, OUTPUT);

  digitalWrite(rlyCloseVent, LOW); // turn off relay if in case it is on for some reason
  digitalWrite(rlyOpenVent, LOW);  // turn off relay if in case it is on for some reason

  Serial.begin(9600);   // initialize serial port for debugging

  // The first time power is turned on, or when recovering from a power outage, check to see if the vent
  // is already open. If open, close it.

  while (digitalRead(maxClosedLimitSw) == HIGH) {
    digitalWrite(rlyCloseVent, HIGH);
  }

  digitalWrite(rlyCloseVent, LOW);  // makes sure that the relay is off
}

void loop() {
  int heatCallReading = digitalRead(heatCallPin);
  if (heatCallReading != lastHeatCallReading) {       //if the pin's reading does not match previous reading, record the time
    lastDebounceTime = millis();
  }
  if ((millis() - lastDebounceTime) > debounceDelay) { //if the new reading has remained stable for long enough

    if (heatCallReading != heatCall) {                 //see if it matches the prevous status. If it's different,
      heatCall = heatCallReading;                      //then status has really changed. Reset the status.

      Serial.print ("HeatCall is now = ");
      Serial.println (heatCall);
      delay(1000);
    }
  }

  lastHeatCallReading = heatCallReading;  // reset the reading to use as future comparison

  Serial.print ("heatCall after debounce = ");
  Serial.println (heatCall);
  delay(2000);

  // HeatCall is established. Respond to heatcall

  if (heatCall == HIGH and digitalRead(maxClosedLimitSw) == LOW) {  //call for heat, vent is closed
    Serial.print ("vent started opening at ");
    Serial.println (millis());
    while (digitalRead(maxOpenLimitSw) == HIGH) {
      digitalWrite(rlyOpenVent, HIGH);  //open the vent
    }
    Serial.print ("vent is now opened at ");
    Serial.println (millis());
    digitalWrite(rlyOpenVent, LOW);  //stop opening the vent
  }

  if (heatCall == LOW and digitalRead(maxOpenLimitSw) == LOW) {     //no call for heat, vent is open
    Serial.print ("vent started closing at ");
    Serial.println (millis());
    while (digitalRead(maxClosedLimitSw) == HIGH) {
      digitalWrite(rlyCloseVent, HIGH);  //close the vent
    }
    Serial.print ("vent is now closed at ");
    Serial.println (millis());
    digitalWrite(rlyCloseVent, LOW);  //stop closing the vent
  }

}
